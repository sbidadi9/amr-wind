<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Theory Manual &mdash; AMR-Wind 0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Mapping definition" href="mapping.html" />
    <link rel="prev" title="Running AMR-Wind" href="../user/run.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            AMR-Wind
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user/user.html">User Manual</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Theory Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#governing-equations">Governing equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discretization">Discretization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#time-step-mol">Time Step – MOL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-step-godunov">Time Step – Godunov</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#solving-physics-on-a-stretched-amrex-mesh">Solving physics on a stretched AMReX mesh</a><ul>
<li class="toctree-l3"><a class="reference internal" href="mapping.html">Mapping definition</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multiphase-flow-modelling">Multiphase flow modelling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#source-terms">Source terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gravity-forcing">Gravity Forcing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#turbulence-models">Turbulence Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#les-models-for-subgrid-scales">LES models for subgrid scales</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#smagorinsky-model">Smagorinsky model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#amdnotherm-model">AMDNoTherm model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#amd-model-for-abl">AMD model (for ABL)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#wall-models">Wall models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#log-law-wall-model">Log-law wall model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constant-stress-model">Constant stress model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#schumann-model">Schumann model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-wall-boundary">Symmetric wall boundary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#navigating-source-code">Navigating source code</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">Developer Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AMR-Wind</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Theory Manual</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/theory/theory.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="theory-manual">
<h1>Theory Manual<a class="headerlink" href="#theory-manual" title="Permalink to this heading"></a></h1>
<section id="governing-equations">
<h2>Governing equations<a class="headerlink" href="#governing-equations" title="Permalink to this heading"></a></h2>
<p>Conservation of fluid mass:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho U)  = 0\]</div>
<p>Conservation of fluid momentum:</p>
<div class="math notranslate nohighlight">
\[\frac{ \partial (\rho U)}{\partial t}
+ \nabla \cdot (\rho U U) + \nabla p = \nabla \cdot \tau + \rho g\]</div>
<p>Incompressibility constraint:</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot U = 0\]</div>
<p>Tracer(s) advection:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \rho s}{\partial t} + \nabla \cdot (\rho U s)  = 0\]</div>
</section>
<section id="discretization">
<h2>Discretization<a class="headerlink" href="#discretization" title="Permalink to this heading"></a></h2>
<p>The numerical methdology used to solve the partial differential equations (PDEs)
within AMR-Wind is documented in <a class="reference external" href="https://ccse.lbl.gov/Publications/almgren/abchw.pdf">Almgren et al. (JCP 1998)</a>.</p>
<section id="time-step-mol">
<h3>Time Step – MOL<a class="headerlink" href="#time-step-mol" title="Permalink to this heading"></a></h3>
<p>In the predictor</p>
<ul class="simple">
<li><p>Define <span class="math notranslate nohighlight">\(U^{MAC,n}\)</span>, the face-centered (staggered) MAC velocity which is used for advection, using <span class="math notranslate nohighlight">\(U^n\)</span></p></li>
<li><p>Define an approximation to the new-time state, <span class="math notranslate nohighlight">\((\rho U)^{\ast}\)</span> by setting</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}(\rho U)^{\ast} &amp;= (\rho U)^n -
\Delta t \left( \nabla \cdot (\rho U^{MAC} U) + \nabla {p}^{n-1/2} \right) \\ &amp;+
\Delta t \left( \nabla \cdot \tau^n + \sum_p \beta_p (V_p - {U}^{\ast}) + \rho g \right)\end{split}\]</div>
<ul class="simple">
<li><p>Project <span class="math notranslate nohighlight">\(U^{\ast}\)</span> by solving</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\nabla \cdot \frac{1}{\rho} \nabla \phi = \nabla \cdot \left( \frac{1}{\Delta t}
U^{\ast}+ \frac{1}{\rho} \nabla {p}^{n-1/2} \right)\]</div>
<p>then defining</p>
<div class="math notranslate nohighlight">
\[U^{\ast \ast} = U^{\ast} - \frac{\Delta t}{\rho} \nabla \phi\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[{p}^{n+1/2, \ast} = \phi\]</div>
<p>In the corrector</p>
<ul class="simple">
<li><p>Define <span class="math notranslate nohighlight">\(U^{MAC,\ast \ast}\)</span> at the “new” time using <span class="math notranslate nohighlight">\(U^{\ast \ast}\)</span></p></li>
<li><p>Define a new approximation to the new-time state, <span class="math notranslate nohighlight">\((\rho U)^{\ast \ast \ast}\)</span> by setting</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}(\rho U)^{\ast \ast \ast} &amp;= (\rho U)^n - \frac{\Delta t}{2} \left( \nabla \cdot (\rho U^{MAC} U)^n + \nabla \cdot (\rho U^{MAC} U)^{\ast \ast}\right) + \\ &amp;+ \frac{\Delta t}{2} \left( \nabla \cdot \tau^n + \nabla \cdot \tau^{\ast \ast \ast} \right) + \Delta t \left( - \nabla {p}^{n+1/2,\ast} + \sum_p \beta_p (V_p - {U}^{\ast \ast \ast}) + \rho g \right)\end{split}\]</div>
<ul class="simple">
<li><p>Project <span class="math notranslate nohighlight">\(U^{\ast \ast \ast}\)</span> by solving</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\nabla \cdot \frac{1}{\rho} \nabla \phi = \nabla \cdot \left( \frac{1}{\Delta t} U^{\ast \ast \ast} + \frac{1}{\rho} \nabla {p}^{n+1/2,\ast} \right)\]</div>
<p>then defining</p>
<div class="math notranslate nohighlight">
\[U^{n+1} = U^{\ast \ast \ast} - \frac{\Delta t}{\rho} \nabla \phi\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[{p}^{n+1/2} = \phi\]</div>
</section>
<section id="time-step-godunov">
<h3>Time Step – Godunov<a class="headerlink" href="#time-step-godunov" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Define <span class="math notranslate nohighlight">\(U^{MAC,n+1/2}\)</span>, the MAC velocity which is used for advection. This velocity is interpolated to the cell faces and extrapolated forward in time using a Taylor expansion. Then it is projected to form a divergence-free velocity field.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}u_f^{n+1/2} = u^n \pm \frac{\Delta x}{2}\frac{\partial u}{\partial x} &amp;-
\frac{\Delta t}{2}\left(u^n \frac{\partial u}{\partial x}
+ v^n \frac{\partial u}{\partial y} + w^n \frac{\partial u}{\partial z}\right)
\\ &amp;+
\frac{\Delta t}{2}\left(g + \frac{1}{\rho^n}\left(
-\frac{\partial p^{n-1/2}}{\partial x} + \mu\nabla^2u^n\right) \right)\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\nabla \cdot \frac{\nabla \phi}{\rho^n} = \nabla \cdot \boldsymbol{u}_f^{n+1/2}\]</div>
<div class="math notranslate nohighlight">
\[\boldsymbol{U}^{MAC,n+1/2} = \boldsymbol{u}_f^{n+1/2} - \frac{\nabla \phi}{\rho^n}\]</div>
<ul class="simple">
<li><p>Time discretization of momentum governing equation</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>The time step goes from <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(n+1\)</span> with the right-hand-side at <span class="math notranslate nohighlight">\(n+1/2\)</span>.</p></li>
<li><p>The time discretization of <span class="math notranslate nohighlight">\(\boldsymbol{\tau}\)</span> depends on the method chosen to compute diffusion.</p></li>
</ul>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\begin{split}(\rho \boldsymbol{U})^{n+1} = (\rho \boldsymbol{U})^n &amp;-
\Delta t \left( \nabla \cdot (\rho \boldsymbol{U} \otimes \boldsymbol{U}^{MAC})^{n+1/2}
+ \nabla {p}^{n+1/2} \right) \\ &amp;+
\Delta t \left( \nabla \cdot \boldsymbol{\tau} + \rho^{n+1/2} g \right)\end{split}\]</div>
<ul class="simple">
<li><p>Partition the discretized equation into two steps, the Predictor and Applying the Projection. The predicted state, <span class="math notranslate nohighlight">\(\ast\)</span>, is an approximation to the new-time state, <span class="math notranslate nohighlight">\(n+1\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}(\rho \boldsymbol{U})^{\ast} = (\rho \boldsymbol{U})^n &amp;-
\Delta t \left( \nabla \cdot (\rho \boldsymbol{U} \otimes \boldsymbol{U}^{MAC})^{n+1/2}
+ \nabla {p}^{n-1/2} \right) \\ &amp;+
\Delta t \left( \nabla \cdot \boldsymbol{\tau} + \rho^{n+1/2} g \right)\end{split}\]</div>
<div class="math notranslate nohighlight">
\[(\rho\boldsymbol{U})^{n+1} = (\rho\boldsymbol{U})^{\ast} + \Delta t \nabla p^{n-1/2} - \Delta t \nabla p^{n+1/2}\]</div>
<ul class="simple">
<li><p>In order to calculate <span class="math notranslate nohighlight">\(\rho \boldsymbol{U}^{n+1/2}\)</span> within the advection term, the momentum must be interpolated to the faces and extrapolated forward in time a half step, similar to the face velocities involved in the MAC projection. To do this for the momentum, the routine uses the momentum, pressure gradients, source terms, and diffusion terms at <span class="math notranslate nohighlight">\(n\)</span>, as well as <span class="math notranslate nohighlight">\(\boldsymbol{U}^{MAC,n+1/2}\)</span>.</p></li>
<li><p>In the case of variable density single-phase or multiphase simulations, the density at <span class="math notranslate nohighlight">\(n+1\)</span> is found using separate scalar equations, which are solved during the predictor step. Because density has no projection step,</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\rho^{n+1} = \rho^{\ast}.\]</div>
<p>Therefore, the equation that applies the new pressure gradient becomes</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{U}^{n+1} = \boldsymbol{U}^{\ast} + \frac{1}{\rho^{n+1}}\left(\Delta t \nabla p^{n-1/2} - \Delta t \nabla p^{n+1/2}\right)\]</div>
<ul class="simple">
<li><p>The pressure gradient at <span class="math notranslate nohighlight">\(n+1/2\)</span> is found by solving the projection</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\nabla \cdot \frac{1}{\rho^{n+1}} \nabla p^{n+1/2} = \nabla \cdot \left( \frac{1}{\Delta t}
\boldsymbol{U}^{\ast}+ \frac{1}{\rho^{n+1}} \nabla {p}^{n-1/2} \right)\]</div>
</section>
</section>
<section id="solving-physics-on-a-stretched-amrex-mesh">
<h2>Solving physics on a stretched AMReX mesh<a class="headerlink" href="#solving-physics-on-a-stretched-amrex-mesh" title="Permalink to this heading"></a></h2>
<p>Often for simulations involving walls, (e.g., channel flows, complex terrains etc.) it is desirable to have finer mesh near the wall which gradually coarsens only in the wall-normal direction. Consequently, modifications within AMR-Wind are underway to support solving a non-uniformly spaced mesh while still using most of AMReX’s machinery directed at uniformly-spaced Cartesian meshes. The governing equations solved on a non-uniform stretched mesh are further explained below -</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="mapping.html">Mapping definition</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mapping.html#handy-identities">Handy identities</a></li>
<li class="toctree-l2"><a class="reference internal" href="mapping.html#governing-equations-in-stretched-mesh-space">Governing equations in stretched mesh space</a></li>
<li class="toctree-l2"><a class="reference internal" href="mapping.html#mac-projection">MAC Projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="mapping.html#nodal-projection">Nodal Projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="mapping.html#initial-conditions-computing-the-timestep">Initial conditions &amp; computing the timestep</a></li>
<li class="toctree-l2"><a class="reference internal" href="mapping.html#exceptions-to-the-current-implementation">Exceptions to the current implementation</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="multiphase-flow-modelling">
<h2>Multiphase flow modelling<a class="headerlink" href="#multiphase-flow-modelling" title="Permalink to this heading"></a></h2>
<p>The level-set (LS) method was introduced by cite{OsherSethian1988} to simulate the motion of a surface with curvature dependent speed. In the LS method, the two-phase interface is represented implicitly by a signed distance function (also called level-set function)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\phi ( \mathbf{x},t ) = \begin{cases}
   d , &amp; \text{in water} \\
   0,  &amp; \text{on surface} \\
   -d, &amp; \text{in air.}
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the distance from point <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> to the interface.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + \mathbf{u} \nabla \phi = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{u}=(u_x,u_y,u_z)\)</span> is the velocity vector.
Re-initialization of the level-set</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial \tau} = \text{sgn}(\phi^0)(1-|\nabla \phi|)\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi^0=\phi(x,0)\)</span> represents the location of the interface.</p>
</section>
<section id="source-terms">
<h2>Source terms<a class="headerlink" href="#source-terms" title="Permalink to this heading"></a></h2>
<section id="gravity-forcing">
<h3>Gravity Forcing<a class="headerlink" href="#gravity-forcing" title="Permalink to this heading"></a></h3>
<p>The implementation of this source term allows the user to choose the full gravity term (<span class="math notranslate nohighlight">\(\rho g\)</span>) or a perturbational form (<span class="math notranslate nohighlight">\((\rho - \rho_0) g\)</span>). By default, the full term is used, but the perturbational form can be turned on by adding <code class="docutils literal notranslate"><span class="pre">ICNS.use_perturb_pressure</span> <span class="pre">=</span> <span class="pre">true</span></code> to the input file.</p>
<p>The reference density (<span class="math notranslate nohighlight">\(\rho_0\)</span>) is defined as <code class="docutils literal notranslate"><span class="pre">1.0</span></code> by default, can be defined as a constant through the input argument, <code class="docutils literal notranslate"><span class="pre">incflo::density</span></code>, or can be defined as a spatially varying field within the flow setup (see physics/multiphase/Multiphase.cpp).</p>
<p>Using the perturbational form implies that the hydrostatic pressure is removed from the pressure variable, including its output. This means that the solution to the Poisson equation is actually the perturbational pressure, <span class="math notranslate nohighlight">\(p'\)</span>, not <span class="math notranslate nohighlight">\(p\)</span>. If the full pressure, <span class="math notranslate nohighlight">\(p\)</span>, is desired for analysis or postprocessing purposes, the hydrostatic pressure can be added back to the pressure field via the input argument <code class="docutils literal notranslate"><span class="pre">ICNS.reconstruct_true_pressure</span> <span class="pre">=</span> <span class="pre">true</span></code>. In order for this to operate in the code, the reference pressure field must be defined for the specific flow case being run.</p>
<ul class="simple">
<li><p>An example of this is in physics/multiphase/Multiphase.cpp. To construct the reference pressure field, the reference gravity term must be integrated. This particular example assumes that the reference density only varies in z (or is constant), gravity acts only in z, and the hydrostatic pressure at zhi is equal to 0.</p></li>
<li><p>In mathematical form, the derivation and calculation of the full pressure is as follows:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\nabla p = \nabla p' + \rho_0 \boldsymbol{g}\]</div>
<ul class="simple">
<li><p>assume <span class="math notranslate nohighlight">\(\boldsymbol{g} = g\hat{k}\)</span> and <span class="math notranslate nohighlight">\(\frac{dp_0}{dz} = g\hat{k}\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[p = p' + \int_{z_{min}}^z \rho_0 g dz + p(z = z_{min})\]</div>
<ul class="simple">
<li><p>reframe in reference to the top boundary, and assume <span class="math notranslate nohighlight">\(p(z = z_{max}) = 0\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[p = p' - \int_z^{z_{max}} \rho_0 g dz + p(z = z_{max}) = p' - \int_z^{z_{max}} \rho_0 g dz\]</div>
</section>
</section>
<section id="turbulence-models">
<h2>Turbulence Models<a class="headerlink" href="#turbulence-models" title="Permalink to this heading"></a></h2>
<section id="les-models-for-subgrid-scales">
<h3>LES models for subgrid scales<a class="headerlink" href="#les-models-for-subgrid-scales" title="Permalink to this heading"></a></h3>
<section id="smagorinsky-model">
<h4>Smagorinsky model<a class="headerlink" href="#smagorinsky-model" title="Permalink to this heading"></a></h4>
<p>Simple eddy viscosity model, the dissipation is calculated using the
resolved strain rate tensor and the grid resolution as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \tau_{ij} &amp;= -2 \nu_t \widetilde{S}_{ij} \\
    \nu_t &amp;= C_s^2 \Delta^2 (2 \langle S_{ij} S_{ij} \rangle)^{\frac{1}{2}}
\end{aligned}\end{split}\]</div>
</section>
<section id="amdnotherm-model">
<h4>AMDNoTherm model<a class="headerlink" href="#amdnotherm-model" title="Permalink to this heading"></a></h4>
<p>This is the implementation of the base AMD model, useful for flows without a temperature field.</p>
<p>The eddy viscosity is calculated using an anisotropic derivative with a
different filter width in each direction</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \hat{\partial}_i &amp;= \sqrt{C} \delta_i \partial_i \textrm{ for } i=1,2,3 \\
    C &amp;= 1/3, \textrm{ Poincare coefficient for } 2^{nd} \textrm{ order gradient} \\
    \delta_i &amp;= \textrm{Filter width along dimension } i \textrm{ for anisotropic grids}
\end{aligned}\end{split}\]</div>
<p>The anisotropic derivative is used to define the eddy viscosity as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \tau_{ij} &amp;= -2 \nu_t \widetilde{S}_{ij} \\
    \nu_t &amp;= \frac{- (\hat{\partial}_k \widetilde{u}_i) (\hat{\partial}_k \widetilde{u}_j) \widetilde{S}_{ij}}{ (\partial_l \widetilde{u}_m) (\partial_l \widetilde{u}_m) }
\end{aligned}\end{split}\]</div>
</section>
<section id="amd-model-for-abl">
<h4>AMD model (for ABL)<a class="headerlink" href="#amd-model-for-abl" title="Permalink to this heading"></a></h4>
<p>The eddy viscosity is calculated using an anisotropic derivative with a
different filter width in each direction</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \hat{\partial}_i &amp;= \sqrt{C} \delta_i \partial_i \textrm{ for } i=1,2,3 \\
    C &amp;= 1/3 \textrm{ Poincare coefficient for } 2^{nd} \textrm{ order gradient} \\
    \delta_i &amp;= \textrm{Filter width along dimension } i \textrm{ for anisotropic grids}\\
    \beta &amp;= g/\Theta_0 \textrm{ Gravity constant over reference temperature}
\end{aligned}\end{split}\]</div>
<p>The anisotropic derivative is used to define the eddy viscosity as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \tau_{ij} &amp;= -2 \nu_t \widetilde{S}_{ij} \\
    \nu_t &amp;= \frac{- (\hat{\partial}_k \widetilde{u}_i) (\hat{\partial}_k \widetilde{u}_j) \widetilde{S}_{ij} +  \beta (\hat{\partial}_k \widetilde{w}) (\hat{\partial}_k (\widetilde{\Theta} - \langle {\widetilde{\Theta}} \rangle) )  }{ (\partial_l \widetilde{u}_m) (\partial_l \widetilde{u}_m) } \\
    \tau_{\theta j} &amp;= -2 D_e \frac{\partial \widetilde{\Theta}}{\partial x_j} \\
    D_e &amp;= \frac{- (\hat{\partial}_k \widetilde{u}_i) (\hat{\partial}_k \widetilde{\Theta}) \partial_i \widetilde{\Theta} }{(\partial_l \widetilde{\Theta}) (\partial_l \widetilde{\Theta})}
\end{aligned}\end{split}\]</div>
<ul class="simple">
<li><p><strong>Implementation details:</strong></p></li>
</ul>
<p>For ease of implementation, each part of <span class="math notranslate nohighlight">\(\nu_t\)</span> and <span class="math notranslate nohighlight">\(D_e\)</span>
is expanded in this subsection, these are used in <code class="docutils literal notranslate"><span class="pre">AMD.h</span></code> within
functions <code class="docutils literal notranslate"><span class="pre">amd_muvel</span></code> and <code class="docutils literal notranslate"><span class="pre">amd_thermal_diff</span></code>.</p>
<p><strong>Terms for</strong> <span class="math notranslate nohighlight">\(\nu_t\)</span> <strong>in</strong> <code class="docutils literal notranslate"><span class="pre">amd_muvel</span></code></p>
<ol class="arabic">
<li><p><span class="math notranslate nohighlight">\((\hat{\partial}_k \widetilde{u}_i) (\hat{\partial}_k \widetilde{u}_j) \widetilde{S}_{ij}\)</span>
is a contraction of 2 symmetric tensors, <span class="math notranslate nohighlight">\((\hat{\partial}_k
\widetilde{u}_i) (\hat{\partial}_k \widetilde{u}_j)\)</span> and
<span class="math notranslate nohighlight">\(\widetilde{S}_{ij}\)</span>, therefore we get 6 unique terms, 3
diagonals and 3 off-diagonals. The diagonal terms get a factor of 2
from <span class="math notranslate nohighlight">\(\widetilde{S}_{ij}\)</span> and the off-diagonal terms get a
factor of 2 from symmetry. This term is <code class="docutils literal notranslate"><span class="pre">num_shear</span></code>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \begin{split}
    (\hat{\partial}_k \widetilde{u}_i) (\hat{\partial}_k \widetilde{u}_j) \widetilde{S}_{ij} = \\
    2*C* [\\
    {}&amp;u_x*(u_x^2 dx^2 + u_y^2 dy^2 + u_z^2 dz^2) +\\
    {}&amp;v_y*(v_x^2 dx^2 + v_y^2 dy^2 + v_z^2 dz^2) +\\
    {}&amp;w_z*(w_x^2 dx^2 + w_y^2 dy^2 + w_z^2 dz^2) +\\
    {}&amp;(u_y+v_x) * (
    u_x v_x dx^2 +
    u_y v_y dy^2 +
    u_z v_z dz^2
    ) +\\
    {}&amp;(u_z+w_x) * (
    u_x w_x dx^2 +
    u_y w_y dy^2 +
    u_z w_z dz^2
    ) +\\
    {}&amp;(v_z+w_y) * (
    v_x w_x dx^2 +
    v_y w_y dy^2 +
    v_z w_z dz^2
    )\\
    ]
    \end{split}
\end{aligned}\end{split}\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\(\beta (\hat{\partial}_k \widetilde{w}) (\hat{\partial}_k (\widetilde{\Theta} - \langle {\widetilde{\Theta}} \rangle) )\)</span>
is implemented as <code class="docutils literal notranslate"><span class="pre">num_buoy</span></code></p>
<div class="math notranslate nohighlight">
\[\beta (\hat{\partial}_k \widetilde{w}) (\hat{\partial}_k (\widetilde{\Theta} - \langle {\widetilde{\Theta}} \rangle) ) =
\beta* C* ( w_x \Theta_x dx^2 + w_y \Theta_y dy^2 + w_z \Theta_z dz^2)\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\((\partial_l \widetilde{u}_m) (\partial_l \widetilde{u}_m)\)</span> is
double contraction of rank 2 tensors, and has 9 unique terms. This is
implemented as <code class="docutils literal notranslate"><span class="pre">denom</span></code></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \begin{split}
        (\partial_l \widetilde{u}_m) (\partial_l \widetilde{u}_m) = \\
        {}&amp; u_x u_x + u_y u_y + u_z u_z \\
        {}&amp; v_x v_x + v_y v_y + v_z v_z \\
        {}&amp; w_x w_x + w_y w_y + w_z w_z
    \end{split}
\end{aligned}\end{split}\]</div>
</li>
</ol>
<p><strong>Terms for</strong> <span class="math notranslate nohighlight">\(D_e\)</span> <strong>in</strong> <code class="docutils literal notranslate"><span class="pre">amd_thermal_diff</span></code></p>
<ol class="arabic">
<li><p><span class="math notranslate nohighlight">\((\hat{\partial}_k \widetilde{u}_i) (\hat{\partial}_k \widetilde{\Theta}) \partial_i \widetilde{\Theta}\)</span>
is a double contraction, has 9 unique terms. This is implemented as
<code class="docutils literal notranslate"><span class="pre">num</span></code></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \begin{split}
    (\hat{\partial}_k \widetilde{u}_i) (\hat{\partial}_k \widetilde{\Theta}) \partial_i \widetilde{\Theta} = \\
    C*[ \\
    {}&amp; (u_x \Theta_x dx^2 + u_y \Theta_y dy^2 + u_z \Theta_z dz^2)*\Theta_x +\\
    {}&amp; (v_x \Theta_x dx^2 + v_y \Theta_y dy^2 + v_z \Theta_z dz^2)*\Theta_y +\\
    {}&amp; (w_x \Theta_x dx^2 + w_y \Theta_y dy^2 + w_z \Theta_z dz^2)*\Theta_z \\
    ]
    \end{split}
\end{aligned}\end{split}\]</div>
</li>
<li><p><span class="math notranslate nohighlight">\((\partial_l \widetilde{\Theta}) (\partial_l \widetilde{\Theta}) = \Theta_x^2 + \Theta_y^2 + \Theta_z^2\)</span>
is implemented as <code class="docutils literal notranslate"><span class="pre">denom</span></code></p></li>
</ol>
<ul class="simple">
<li><p><strong>Unit tests</strong></p></li>
</ul>
<p>There is a simple unit test for both <span class="math notranslate nohighlight">\(\nu_t\)</span> and <span class="math notranslate nohighlight">\(D_e\)</span> in
<code class="docutils literal notranslate"><span class="pre">unit_tests/turbulence/test_turbulence_LES.cpp</span></code> under
<code class="docutils literal notranslate"><span class="pre">test_AMD_setup_calc</span></code>.</p>
</section>
</section>
</section>
<section id="wall-models">
<h2>Wall models<a class="headerlink" href="#wall-models" title="Permalink to this heading"></a></h2>
<p>The wall models descibed in this section are implemented in <code class="docutils literal notranslate"><span class="pre">AMR-wind</span></code> for
running wall-bounded flows (non-ABL cases).</p>
<section id="log-law-wall-model">
<h3>Log-law wall model<a class="headerlink" href="#log-law-wall-model" title="Permalink to this heading"></a></h3>
<p>This wall model computes the local <span class="math notranslate nohighlight">\(u_\tau\)</span> from the velocity at
the first grid cell, and uses this to compute the shear stress, which is
then used as a boundary condition.</p>
<p>The log law:</p>
<div class="math notranslate nohighlight">
\[u_{\mathrm{mag}} = u_\tau \left(\frac{1}{\kappa}\log\left(\frac{u_\tau z}{\nu}\right) + B\right). \label{eq:loglaw}\]</div>
<p>Given a horizontal velocity magnitude
<span class="math notranslate nohighlight">\(u_{\mathrm{mag}} = \sqrt{u^2 + v^2}\)</span> at
<span class="math notranslate nohighlight">\(z = z_{\mathrm{ref}}\)</span>, <span class="math notranslate nohighlight">\(u_\tau\)</span> can be computed using a
non-linear solve to satisfy <a class="reference external" href="#eq:loglaw">[eq:loglaw]</a>.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">AMR-wind</span></code> Newton-Raphson iterations are used with a convergence
criterion of <span class="math notranslate nohighlight">\(\lvert u_\tau^{n+1} - u_\tau^n \rvert &lt; 10^{-5}\)</span>.
For this, derivative of
<span class="math notranslate nohighlight">\(\frac{\partial u_{\mathrm{mag}}}{\partial {u_\tau}}\)</span> is used,</p>
<div class="math notranslate nohighlight">
\[\frac{\partial u_{\mathrm{mag}}}{\partial {u_\tau}} = \left(\frac{1}{\kappa}\left(1+\log\left(\frac{u_\tau z_{\mathrm{ref}}}{\nu}\right)\right) + B\right)\]</div>
<div class="math notranslate nohighlight">
\[u_\tau^{n+1} = u_\tau^{n} - \left(u_\tau^n \left(\frac{1}{\kappa}\log\left(\frac{u_\tau^n z_{\mathrm{ref}}}{\nu}\right) + B\right) - u_{\mathrm{mag}}\right)/\frac{\partial u_{\mathrm{mag}}}{\partial {u_\tau}}.\]</div>
<p>Finally, the shear stress is calculated as,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \tau_{xz} &amp;= u_\tau^2 \frac{u}{u_\mathrm{mag}} \\
    \tau_{yz} &amp;= u_\tau^2 \frac{v}{u_\mathrm{mag}}
\end{aligned}\end{split}\]</div>
</section>
<section id="constant-stress-model">
<h3>Constant stress model<a class="headerlink" href="#constant-stress-model" title="Permalink to this heading"></a></h3>
<p>NOTE: This wall model will be ill-posed unless combined with a Dirichlet
boundary condition on the other wall, <span class="math notranslate nohighlight">\(\langle u \rangle\)</span> can
drift by a constant otherwise.</p>
<p>This is a trivial wall model, where the shear stresses are specified as
constants. For a pressure gradient driven channel,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    u_\tau^2 &amp;= -\frac{\mathrm{d} P}{\mathrm{d} x} \\
    \tau_{xz} &amp;= u_\tau^2 \\
    \tau_{yz} &amp;= 0
\end{aligned}\end{split}\]</div>
</section>
<section id="schumann-model">
<h3>Schumann model<a class="headerlink" href="#schumann-model" title="Permalink to this heading"></a></h3>
<p>NOTE: This wall model will be ill-posed unless combined with a Dirichlet
boundary condition on the other wall, <span class="math notranslate nohighlight">\(\langle u \rangle\)</span> can
drift by a constant otherwise.</p>
<p>This model is a modified version of the constant stress model, where the
fluctuations from a reference height <span class="math notranslate nohighlight">\(z_\mathrm{ref}\)</span> are used to
add fluctuations in the shear stress.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    u_\tau^2 &amp;= -\frac{\mathrm{d} P}{\mathrm{d} x} \\
    \tau_{xz} &amp;= u_\tau^2 \frac{u}{\langle u_\mathrm{mag} \rangle} \\
    \tau_{yz} &amp;= u_\tau^2 \frac{v}{\langle u_\mathrm{mag} \rangle}
\end{aligned}\end{split}\]</div>
<p>where, <span class="math notranslate nohighlight">\(\langle u_\mathrm{mag} \rangle\)</span> is the planar average of
<span class="math notranslate nohighlight">\(u_{\mathrm{mag}} = \sqrt{u^2 + v^2}\)</span> at <span class="math notranslate nohighlight">\(z_\mathrm{ref}\)</span>.</p>
</section>
<section id="symmetric-wall-boundary">
<h3>Symmetric wall boundary<a class="headerlink" href="#symmetric-wall-boundary" title="Permalink to this heading"></a></h3>
<p>This is a boundary condition to for flows with a symmetry across the
z direction (example: <em>half-channel</em> simulations) at the centerline.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \tau_{xz} &amp;= 0 \\
    \tau_{yz} &amp;= 0 \\
    w &amp;= 0
\end{aligned}\end{split}\]</div>
</section>
</section>
<section id="navigating-source-code">
<h2>Navigating source code<a class="headerlink" href="#navigating-source-code" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">AMR-Wind</span></code> is built on top of <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/">AMReX library</a>. Users are strongly
recommended to read through the AMReX documentation and understand the basic
AMReX concepts before jumping into the AMR-Wind source code.</p>
<p>The <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/Basics_Chapter.html">Basics section</a> provides a
thorough overview of the basic datastructures and ways to interact with these
structures. The <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/GPU_Chapter.html">GPU section</a> provides an
overview of the AMReX GPU strategy and the higher-level functions (e.g.,
<code class="docutils literal notranslate"><span class="pre">parallel-for</span></code> abstractions) available to write GPU-ready code within
AMR-Wind. The <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/LinearSolvers_Chapter.html">Linear Solvers section</a>
provides an overview of the multi-level multigrid (MLMG) solvers used to solve
the various linear systems within AMR-Wind.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../user/run.html" class="btn btn-neutral float-left" title="Running AMR-Wind" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mapping.html" class="btn btn-neutral float-right" title="Mapping definition" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>